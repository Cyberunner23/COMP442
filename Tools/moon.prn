MOON listing of moon/samples/lib.m.

    1     0 % A Simple MOON Library
    2     0 % Author: Peter Grogono
    3     0 % Last modified: 27 Jan 1995
    4     0 
    5     0 % Conventions
    6     0 %   r14 is the Stack Pointer
    7     0 %   -4(r14) is used to store the link, if necessary.
    8     0 %   -8(r14) contains the first argument.
    9     0 %   -12(r14) contains the second argument, and so on.
   10     0 %   r15 contains the link.
   11     0 %   r13 contains the result of a function.
   12     0 
   13     0 %   Strings are null terminated.  Strings are passed and returned to
   14     0 %   library functions as pointers.  It is the caller's responsibility to
   15     0 %   provide storage for strings.
   16     0 
   17     0 %   "->" is read "points to".
   18     0 
   19     0           align               % In case previous file misaligned
   20     0 
   21     0 % Write a string to stdout.
   22     0 % Entry: -8(r14) -> string argument.
   23     0 
   24     0 putstr    lw    r1,-8(r14)    % i := r1
   25     4           addi  r2,r0,0
   26     8 putstr1   lb    r2,0(r1)      % ch := B[i]
   27    12           ceqi  r3,r2,0
   28    16           bnz   r3,putstr2    % branch if ch = 0
   29    20           putc  r2
   30    24           addi  r1,r1,1       % i++
   31    28           j     putstr1
   32    32 putstr2   jr    r15
   33    36 
   34    36 % Read a string from stdin.  Read until CR (ASCII 13) but do not store
   35    36 % the CR.
   36    36 % Entry: -8(r14) -> buffer.
   37    36 
   38    36 getstr    lw    r1,-8(r14)    % i := r1
   39    40 getstr1   getc  r2            % get ch
   40    44           ceqi  r3,r2,10
   41    48           bnz   r3,getstr2    % branch if ch = CR
   42    52           sb    0(r1),r2      % B[i] := ch
   43    56           addi  r1,r1,1       % i++
   44    60           j     getstr1
   45    64 getstr2   sb    0(r1),r0      % B[i] := '\0'
   46    68           jr    r15
   47    72 
   48    72 % Convert string to integer.  Skip leading blanks.  Accept leading sign.
   49    72 % Entry: -8(r14) -> string.
   50    72 % Exit:  result in r13
   51    72 
   52    72 strint    addi  r13,r0,0      % R := 0 (result)
   53    76           addi  r4,r0,0       % S := 0 (sign)
   54    80           lw    r1,-8(r14)    % i := r1
   55    84           addi  r2,r0,0
   56    88 strint1   lb    r2,0(r1)      % ch := B[i]
   57    92           cnei  r3,r2,32
   58    96           bnz   r3,strint2    % branch if ch != blank
   59   100           addi  r1,r1,1
   60   104           j     strint1
   61   108 strint2   cnei  r3,r2,43
   62   112           bnz   r3,strint3    % branch if ch != "+"
   63   116           j     strint4
   64   120 strint3   cnei  r3,r2,45
   65   124           bnz   r3,strint5    % branch if ch != "-"
   66   128           addi  r4,r4,1       % S := 1
   67   132 strint4   addi  r1,r1,1       % i++
   68   136           lb    r2,0(r1)      % ch := B[i]
   69   140 strint5   clti  r3,r2,48
   70   144           bnz   r3,strint6    % branch if ch < "0"
   71   148           cgti  r3,r2,57
   72   152           bnz   r3,strint6    % branch if ch > "9"
   73   156           subi  r2,r2,48      % ch -= "0"
   74   160           muli  r13,r13,10    % R *= 10
   75   164           add   r13,r13,r2    % R += ch
   76   168           j     strint4
   77   172 strint6   ceqi  r3,r4,0
   78   176           bnz   r3,strint7    % branch if S = 0
   79   180           sub   r13,r0,r13    % R := -R
   80   184 strint7   jr    r15
   81   188 
   82   188 % Convert signed integer to string.
   83   188 % Entry: -8(r14) is the integer.
   84   188 %        -12(r14) -> buffer containing at least 12 bytes.
   85   188 % Exit:  r13 -> first character of result string.
   86   188 
   87   188 intstr    lw    r13,-12(r14)
   88   192           addi  r13,r13,11    % r13 points to end of buffer
   89   196           sb    0(r13),r0     % store terminator
   90   200           lw    r1,-8(r14)    % r1 := N (to be converted)
   91   204           addi  r2,r0,0       % S := 0 (sign)
   92   208           cgei  r3,r1,0
   93   212           bnz   r3,intstr1    % branch if N >= 0
   94   216           addi  r2,r2,1       % S := 1
   95   220           sub   r1,r0,r1      % N := -N
   96   224 intstr1   addi  r3,r1,0       % D := N (next digit)
   97   228           modi  r3,r3,10      % D mod= 10
   98   232           addi  r3,r3,48      % D += "0"
   99   236           subi  r13,r13,1     % i--
  100   240           sb    0(r13),r3     % B[i] := D
  101   244           divi  r1,r1,10      % N div= 10
  102   248           cnei  r3,r1,0
  103   252           bnz   r3,intstr1    % branch if N != 0
  104   256           ceqi  r3,r2,0
  105   260           bnz   r3,intstr2    % branch if S = 0
  106   264           subi  r13,r13,1     % i--
  107   268           addi  r3,r0,45
  108   272           sb    0(r13),r3     % B[i] := "-"
  109   276 intstr2   jr    r15
  110   280 
  111   280 % Return length of string.
  112   280 % Entry: -8(r14) -> string.
  113   280 % Exit:  r13 = length of string.
  114   280 
  115   280 lenstr   lw    r1,-8(r14)     % i -> string
  116   284          addi  r13,r0,0       % L := 0
  117   288          addi  r2,r0,0
  118   292 lenstr1  lb    r2,0(r1)       % ch := B[i]
  119   296          ceqi  r3,r2,0
  120   300          bnz   r3,lenstr2     % branch if ch = 0
  121   304          addi  r13,r13,1      % L++
  122   308          addi  r1,r1,1        % i++
  123   312          j     lenstr1
  124   316 lenstr2  jr    r15
  125   320 
  126   320 % Concatenate strings: Z := X + Y.
  127   320 % Entry:   -8(r14)  ->  X
  128   320 %         -12(r14)  ->  Y
  129   320 %         -16(r14)  ->  Z
  130   320 % The result string is assumed to be large enough to hold the result.
  131   320 
  132   320 strcat   lw    r1,-16(r14)    % r1 -> Z
  133   324          lw    r2,-8(r14)     % r2 -> X
  134   328          addi  r3,r0,0        % r3 = current character
  135   332 strcat1  lb    r3,0(r2)       % char from X
  136   336          ceqi  r4,r3,0
  137   340          bnz   r4,strcat2     % branch at end of X
  138   344          sb    0(r1),r3       % copy char to Z
  139   348          addi  r1,r1,1
  140   352          addi  r2,r2,1
  141   356          j     strcat1
  142   360 strcat2  lw    r2,-12(r14)    % r2 -> Y
  143   364 strcat3  lb    r3,0(r2)       % char from Y
  144   368          ceqi  r4,r3,0
  145   372          bnz   r4,strcat4     % branch at end of Y
  146   376          sb    0(r1),r3       % copy char to Z
  147   380          addi  r1,r1,1
  148   384          addi  r2,r2,1
  149   388          j     strcat3
  150   392 strcat4  sb    0(r1),r0       % Store terminator
  151   396          jr    r15
  152   400 
  153   400 % The string comparison functions all use strcmp, defined below.
  154   400 % They are all short; a smart compiler could generate this code
  155   400 % directly, avoiding the overhead of an extra level of function
  156   400 % call.
  157   400 % For each function:
  158   400 % Entry: -8(r14)  -> string A
  159   400 %        -12(r14) -> string B
  160   400 % Exit:  r13 = 1 for true and 0 for false.
  161   400 % Note that r11 is used for the link to avoid saving r15.
  162   400 
  163   400 streq    jl    r11,strcmp
  164   404          lw    r13,eq(r13)
  165   408          jr    r15
  166   412 eq       dw    1,0,0
  167   424 
  168   424 strne    jl    r11,strcmp
  169   428          lw    r13,ne(r13)
  170   432          jr    r15
  171   436 ne       dw    0,1,1
  172   448 
  173   448 strlt    jl    r11,strcmp
  174   452          lw    r13,lt(r13)
  175   456          jr    r15
  176   460 lt       dw    0,1,0
  177   472 
  178   472 strle    jl    r11,strcmp
  179   476          lw    r13,le(r13)
  180   480          jr    r15
  181   484 le       dw    1,1,0
  182   496 
  183   496 strgt    jl    r11,strcmp
  184   500          lw    r13,gt(r13)
  185   504          jr    r15
  186   508 gt       dw    0,0,1
  187   520 
  188   520 strge    jl    r11,strcmp
  189   524          lw    r13,ge(r13)
  190   528          jr    r15
  191   532 ge       dw    1,0,1
  192   544 
  193   544 % Compare strings.
  194   544 % Entry: -8(r14)  -> string A
  195   544 %        -12(r14) -> string B
  196   544 %             ( 0   if A = B
  197   544 % Exit: r13 = < 4   if A < B
  198   544 %             ( 8   if A > B
  199   544 % Note that r11 is the link.
  200   544 
  201   544 strcmp   lw    r1,-8(r14)
  202   548          lw    r2,-12(r14)
  203   552          addi  r3,r0,0
  204   556          addi  r4,r0,0
  205   560 strcmp1  lb    r3,0(r1)       % get A[i]
  206   564          lb    r4,0(r2)       % get B[j]
  207   568          ceqi  r5,r3,0
  208   572          bnz   r5,strcmp2     % branch if end of A
  209   576          ceqi  r5,r4,0
  210   580          bnz   r5,strcmp4     % branch if end of B
  211   584          ceq   r5,r3,r4
  212   588          bz    r5,strcmp3     % branch if A[i] != B[i]
  213   592          addi  r1,r1,1        % i++
  214   596          addi  r2,r2,1        % j++
  215   600          j     strcmp1
  216   604 strcmp2  ceqi  r5,r4,0
  217   608          bz    r5,strcmp5     % branch if not end of B
  218   612          addi  r13,r0,0       % A = B
  219   616          jr    r11
  220   620 strcmp3  clt   r5,r3,r4
  221   624          bnz   r5,strcmp5     % branch if A[i] < B[i]
  222   628 strcmp4  addi  r13,r0,8       % A > B
  223   632          jr    r11
  224   636 strcmp5  addi  r13,r0,4       % A < B
  225   640          jr    r11
  226   644 
  227   644 % String indexing: return the string S[M].  The value is returned as a
  228   644 % string rather than as a character for compatibility with other string
  229   644 % processing functions.  Also, we must distinguish the empty string
  230   644 % from a character.
  231   644 % Entry: -8(r14)  -> S
  232   644 %        -12(r14) -> M
  233   644 %        -16(r14) -> T, the output string.
  234   644 % Exit:  the output string contains the selected character, or is null.
  235   644 
  236   644 stridx   lw    r1,-8(r14)    % i
  237   648          lw    r2,-12(r14)
  238   652          lw    r3,-16(r14)
  239   656          subi  r2,r2,1
  240   660          addi  r4,r0,0
  241   664 stridx1  lb    r4,0(r1)      % ch := S[i]
  242   668          ceqi  r5,r4,0
  243   672          bnz   r5,stridx3    % branch if ch = 0
  244   676          cge   r5,r1,r2
  245   680          bnz   r5,stridx2    % branch if i >= M
  246   684          addi  r1,r1,1       % i++
  247   688          j     stridx1
  248   692 stridx2  sb    0(r3),r4      % T[0] := S[M]
  249   696          addi  r3,r3,1
  250   700 stridx3  sb    0(r3),r0      % T[k] := 0
  251   704          jr    r15
  252   708 
  253   708 % String indexing: return the string S[M..N].
  254   708 % Entry: -8(r14)  -> S
  255   708 %        -12(r14) -> M
  256   708 %        -16(r14) -> N
  257   708 %        -20(r14) -> T, the output string.
  258   708 % Exit:  the output string contains the selected substring, or is null.
  259   708 
  260   708 strsub   lw    r1,-8(r14)
  261   712          lw    r2,-12(r14)
  262   716          lw    r3,-16(r14)
  263   720          lw    r4,-20(r14)
  264   724          subi  r2,r2,1
  265   728          subi  r3,r3,1
  266   732          addi  r5,r0,0
  267   736 strsub1  lb    r5,0(r1)      % ch := S[i]
  268   740          ceqi  r6,r5,0
  269   744          bnz   r6,strsub3    % branch if ch = 0
  270   748          clt   r6,r1,r2
  271   752          bnz   r6,strsub2    % branch if i < M
  272   756          cgt   r6,r1,r3
  273   760          bnz   r6,strsub3    % branch if i > N
  274   764          sb    0(r3),r5      % T[k] := S[i]
  275   768          addi  r3,r3,1       % k++
  276   772 strsub2  addi  r1,r1,1       % i++
  277   776          j     strsub1
  278   780 strsub3  sb    0(r3),r0      % T[k] := 0
  279   784          jr    r15

MOON listing of moon/samples/factorials.m.

    1   788 % MOON simulator: test of recursion
    2   788 
    3   788       entry
    4   788       addi   r14,r0,topaddr  % Set stack pointer
    5   792 
    6   792 loop  
    7   792       lw     r1,arg(r0)     % Fetch argument
    8   796       cgti   r2,r1,12       % and decide whether
    9   800       bnz    r2,stop        % to stop.
   10   804 
   11   804       sw     -8(r14),r1     % Display argument.
   12   808       addi   r1,r0,buf
   13   812       sw     -12(r14),r1
   14   816       jl     r15,intstr
   15   820       sw     -8(r14),r13
   16   824       jl     r15,putstr
   17   828 
   18   828       addi   r1,r0,m1       % "! = "
   19   832       sw     -8(r14),r1
   20   836       jl     r15,putstr
   21   840 
   22   840       lw     r1,arg(r0)     % Fetch argument again
   23   844       sw     -8(r14),r1
   24   848       jl     r15,fac        % and call factorial
   25   852       sw     -8(r14),r13
   26   856       addi   r1,r0,buf
   27   860       sw     -12(r14),r1
   28   864       jl     r15,intstr     % Convert and display result
   29   868       sw     -8(r14),r13
   30   872       jl     r15,putstr
   31   876 
   32   876       addi   r1,r0,m2       % CR
   33   880       sw     -8(r14),r1
   34   884       jl     r15,putstr
   35   888 
   36   888       lw     r1,arg(r0)     % Increment argument
   37   892       addi   r1,r1,1
   38   896       sw     arg(r0),r1
   39   900       j      loop
   40   904 
   41   904 stop  
   42   904       hlt
   43   908 
   44   908 arg   dw     0
   45   912 m1    db     "! = ", 0
   46   917 m2    db     13, 10, 0
   47   920 buf   res    20
   48   940 
   49   940 % Recursive factorial function.
   50   940 % -8(r14) = argument.
   51   940 % r13 = result.
   52   940 fac   sw     -4(r14),r15    % Save link
   53   944       lw     r1,-8(r14)     % Get N
   54   948       ceqi   r2,r1,0
   55   952       bnz    r2,fac1        % branch if N = 0
   56   956       subi   r1,r1,1        % N := N - 1
   57   960       sw     -16(r14),r1    % Store as argument
   58   964       subi   r14,r14,8      % Adjust SP
   59   968       jl     r15,fac        % Recursive call
   60   972       addi   r14,r14,8      % Adjust SP
   61   976       lw     r1,-8(r14)     % Get N again
   62   980       mul    r13,r13,r1     % R := R * N
   63   984       j      fac2
   64   988 fac1  addi   r13,r0,1       % R := 1
   65   992 fac2  lw     r15,-4(r14)    % Restore link
   66   996       jr     r15
   67  1000 
   68  1000 baseaddr

